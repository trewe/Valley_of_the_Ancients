#textdomain wesnoth-Valley_of_the_Ancients

[lua]
    code=<<

	local helper = wesnoth.require "lua/helper.lua"
	local wml_actions = wesnoth.wml_actions

	local function flash_screen(red,green,blue)
		-- usage: call this function by specifying the maximum values for each color. Don't go above 100.
		wml_actions.color_adjust { red = (red * 0.67), green = (green * 0.67), blue = (blue * 0.67) }
		wml_actions.color_adjust { red = red, green = green, blue = blue }
		wml_actions.color_adjust { red = (red * 0.33), green = (green * 0.33), blue = (blue * 0.33) }
		wml_actions.color_adjust { red = 0, green = 0, blue = 0 }
	end

	function wml_actions.flash(cfg)
		local color = cfg.color or helper.wml_error("Missing required color= attribute in [flash].")
		if cfg.sound then
			wml_actions.sound { name = cfg.sound }
		end
		if color == "red" or color == 1 then
			flash_screen( 100, 0, 0 )
		elseif color == "blue" or color == 2 then
			flash_screen( 0, 0, 100 )
		elseif color == "green" or color == 3 then
			flash_screen( 0, 100, 0 )
		elseif color == "purple" or color == 4 then
			flash_screen( 50, 0, 50 )
		elseif color == "black" or color == 5 then
			flash_screen( -50, -50, -50 )
		elseif color == "brown" or color == 6 then
			flash_screen( 95, 65, 0 )
		elseif color == "orange" or color == 7 then
			flash_screen( 100, 100, 0 )
		elseif color == "white" or color == 8 then
			flash_screen( 100, 100, 100 )
		elseif color == "teal" or color == 9 then
			flash_screen( 0, 100, 100 )
		elseif color == "magenta" or color == 0 then
			flash_screen( 100, 0, 100 )
		else
			helper.wml_error("Unsupported color in [flash].")
		end
	end >>
[/lua]

[event]
    name=side turn

    {RANDOM 1..4}

    [flash]
        color=0
        sound=magic-holy-$random|.ogg
    [/flash]

    {VARIABLE version {VOTA_VERSION}}

    [message]
        speaker=narrator
        caption= _ "Rotating War"
        image="portraits/humans/transparent/mage-silver+female.png~FL()~RIGHT()"
        message= _ "
Use the castle rotation to carry out complex strategies, and attempt to control the most of the map.

If you have trouble understanding the scenario, I'd suggest you dry-run it with a few ai first, just to get the feel of the game.

Using fog could also be funny and provide for an interesting gameplay.

If you're certain you found a new bug, please let know the maintainer. Have fun and good luck! This is version $version"
    [/message]

    [store_side]
        variable=stored_side
    [/store_side]

    {FOREACH stored_side i_temp}
        [if]
            [not]
                [have_unit]
                    side=$stored_side[$i_temp].side
                [/have_unit]
            [/not]
            [then]
                {CLEAR_VARIABLE stored_side[$i_temp]}
                {VARIABLE_OP i_temp sub 1}
            [/then]
        [/if]
    {NEXT i_temp}

    {CLEAR_VARIABLE version,random}
[/event]

[event]
    name=die
    first_time_only=no

    [filter]
        canrecruit=yes
    [/filter]

    [chat]
        speaker= _ "Rotating War"
        message= _ "$unit.name, leader of side $unit.side, has been lost."
    [/chat]

    {RANDOM 1..8}
    {LOOKUP_INDEX stored_side side $unit.side side_i}

    [flash]
        color=$stored_side[$side_i].color
        sound=horn-signals/horn-$random|.ogg
    [/flash]

    [modify_side]
        side=$unit.side
        #color=0
        # the server does not like this in the slightest
        # does not cause OOS though, just something... funky
        #controller=null
        #team_name=null
        user_team_name= _ "Defeated"
    [/modify_side]

    [kill]
        side=$unit.side
        canrecruit=no
        animate=no
    [/kill]

    [if]
        {VARIABLE_CONDITIONAL stored_side[$global.next_rotation].side equals $unit.side}
        [then]
            {VARIABLE_OP global.next_rotation add 1}
            [if]
                {VARIABLE_CONDITIONAL global.next_rotation equals $stored_side.length}
                [then]
                    {VARIABLE global.next_rotation -1}
                [/then]
            [/if]
        [/then]
    [/if]
    {CLEAR_VARIABLE random,stored_side[$side_i],side_i}
[/event]

[event]
    name=new turn
    first_time_only=no
    [filter_condition]
        {VARIABLE_CONDITIONAL turn_number not_equals 1}
    [/filter_condition]
    {VARIABLE_OP global.next_rotation add 1}
[/event]

[event]
    name=side turn
    first_time_only=no

    [filter_condition]
        {VARIABLE_CONDITIONAL turn_number not_equals 1}
    [/filter_condition]

    [if]
        {VARIABLE_CONDITIONAL global.next_rotation greater_than_equal_to $stored_side.length}
        [then]
            {VARIABLE global.next_rotation -1}
        [/then]
        [else]
            [fire_event]
                name=rotation
            [/fire_event]
        [/else]
    [/if]
[/event]

[event]
    name=rotation
    first_time_only=no

    [filter_condition]
        {VARIABLE_CONDITIONAL side_number equals $stored_side[$global.next_rotation].side}
    [/filter_condition]

    {LOOKUP_INDEX stored_side side $side_number side_i}

    [flash]
        color=$stored_side[$side_i].color
        sound=dragonstick.ogg
    [/flash]

    [store_unit]
        [filter]
        [/filter]
        variable=all_units
        kill=yes
    [/store_unit]

    {FOREACH global.GamePos.MA i_temp}
        {FOREACH global.GamePos.MA[$i_temp].MT j_temp}
            [if]
                {VARIABLE_CONDITIONAL j_temp equals "$($global.GamePos.MA[$i_temp].MT.length-1")}
                [then]
                    {VARIABLE next_index 0}
                [/then]
                [else]
                    {VARIABLE next_index "$($j_temp+1)"}
                [/else]
            [/if]

            [set_variables]
                name=old_area
                [split]
                    list=$global.GamePos.MA[$i_temp].MT[$j_temp].x
                    separator=,
                    key=x
                [/split]
            [/set_variables]
            [set_variables]
                name=old_area
                mode=merge
                [split]
                    list=$global.GamePos.MA[$i_temp].MT[$j_temp].y
                    separator=,
                    key=y
                [/split]
            [/set_variables]

            [set_variables]
                name=new_area
                [split]
                    list=$global.GamePos.MA[$i_temp].MT[$next_index].x
                    separator=,
                    key=x
                [/split]
            [/set_variables]
            [set_variables]
                name=new_area
                mode=merge
                [split]
                    list=$global.GamePos.MA[$i_temp].MT[$next_index].y
                    separator=,
                    key=y
                [/split]
            [/set_variables]

            {FOREACH new_area k_temp}
                [store_locations]
                    x,y=$new_area[$k_temp].x,$new_area[$k_temp].y
                    variable=new_hex
                [/store_locations]

                [store_locations]
                    x,y=$old_area[$k_temp].x,$old_area[$k_temp].y
                    variable=old_hex
                [/store_locations]

                {VARIABLE unit_x 0}
                [while]
                    {VARIABLE_CONDITIONAL unit_x less_than $all_units.length}
                    {VARIABLE_CONDITIONAL all_units[$unit_x].x not_equals $old_hex.x}
                    [do]
                        {VARIABLE_OP unit_x add 1}
                    [/do]
                [/while]

                [if]
                    {VARIABLE_CONDITIONAL unit_x not_equals $all_units.length}
                    [then]
                        {VARIABLE unit_y 0}
                        [while]
                            {VARIABLE_CONDITIONAL unit_y less_than $all_units.length}
                            [do]
                                [if]
                                    {VARIABLE_CONDITIONAL all_units[$unit_y].y equals $old_hex.y}
                                    [then]
                                        [if]
                                            {VARIABLE_CONDITIONAL all_units[$unit_y].x equals $all_units[$unit_x].x}
                                            [then]
                                                {VARIABLE unit_i $unit_y}
                                                {VARIABLE unit_y 999}
                                            [/then]
                                            [else]
                                                {VARIABLE_OP unit_y add 1}
                                            [/else]
                                        [/if]
                                    [/then]
                                    [else]
                                        {VARIABLE_OP unit_y add 1}
                                    [/else]
                                [/if]
                            [/do]
                        [/while]
                    [/then]
                [/if]

                [if]
                    {VARIABLE_CONDITIONAL unit_x not_equals $all_units.length}
                    {VARIABLE_CONDITIONAL unit_y not_equals $all_units.length}
                    [then]
                        [unstore_unit]
                            variable=all_units[$unit_i]
                            x,y=$new_hex.x,$new_hex.y
                        [/unstore_unit]
                    [/then]
                [/if]
                {CLEAR_VARIABLE unit_x,unit_y,unit_i}

                [if]
                    [have_location]
                        x,y=$old_hex.x,$old_hex.y
                        terrain=*^Bw*
                    [/have_location]
                    [else]
                        [set_variables]
                            name=change_terrain
                            mode=append
                            [value]
                                x,y=$new_hex.x,$new_hex.y
                                terrain=$old_hex.terrain
                            [/value]
                        [/set_variables]
                    [/else]
                [/if]

                [if]
                    [have_location]
                        x,y=$old_hex.x,$old_hex.y
                        terrain=*^V*
                    [/have_location]
                    [then]
                        [set_variables]
                            name=rotate_village
                            mode=append
                            [value]
                                x,y=$new_hex.x,$new_hex.y
                                side=$old_hex.owner_side
                            [/value]
                        [/set_variables]
                    [/then]
                [/if]
                {CLEAR_VARIABLE old_hex,new_hex}
            {NEXT k_temp}
            {CLEAR_VARIABLE next_index,old_area,new_area}
        {NEXT j_temp}
    {NEXT i_temp}

    {QUAKE rumble.ogg}

    [insert_tag]
        name=terrain
        variable=change_terrain
    [/insert_tag]

    [sound]
        name=claws.ogg
    [/sound]

    [insert_tag]
        name=capture_village
        variable=rotate_village
    [/insert_tag]

    [redraw]
        clear_shroud=yes
        [filter_side]
			[has_unit]
				canrecruit=yes
			[/has_unit]
		[/filter_side]
    [/redraw]

    {CLEAR_VARIABLE all_units,change_terrain,rotate_village,side_i}
[/event]
